% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/var_selection.R
\name{var_selection}
\alias{var_selection}
\alias{cut_off}
\alias{get_suffix}
\alias{get_prefix}
\title{Extract character vectors from variable names}
\usage{
cut_off(.ignore, .select = NULL, .vars = NULL)

get_suffix(.select = NULL, .ignore = NULL, .vars = NULL)

get_prefix(.select = NULL, .ignore = NULL, .vars = NULL)
}
\arguments{
\item{.ignore}{A character string containing a <\link[base:regex]{regular expression}> to be
replaced in the selected variable names.}

\item{.select}{A character string containing a regular expression to subset
the variable names supplied in \code{.vars}. If \code{NULL} the \code{.ignore} will be
applied to all variable names in \code{.vars}.}

\item{.vars}{A character vector of variable names (e.g. \code{names(iris)}). When
called within \code{over()} this automatically defaults to the column names of
the underlying data via a call to \code{names(dplyr::across())}.}
}
\value{
A character vector.
\itemize{
\item \code{cut_off()} Replaces the regular expression in \code{.ignore} with an empty
string \code{""} for all selected variable names. Returns only unique
strings that have been cut off (contains neither \code{NA} nor empty strings).
\item \code{get_suffix()} In a first step, for all selected variable names, characters
starting from the left are removed if all variables share the same character
at the same position, thus leaving only the variables suffixes. Before
returning the suffixes the regular expression in \code{.ignore} is replaced with
an empty string \code{""}. A look at the examples is highly recommended.
\item \code{get_prefix()} The same as \code{get_suffix()}, but here characters are removed
starting from the right, thus leaving only the variables prefixes.
}
}
\description{
The following string selection helpers extract strings from selected variable
names.
}
\section{Examples}{


The variable string selection helpers can be used within \code{over()} without
specifying the \code{.vars} argument. They can be used outside \code{over()} to test
whether the regular expressions are correctly specified.
Let's first attach \code{dplyr} and have a look at the names of our example data:\if{html}{\out{<div class="r">}}\preformatted{library(dplyr)

names(csat)
#>  [1] "cust_id"         "type"            "product"         "csat"            "postal_contact"  "postal_rating"  
#>  [7] "phone_contact"   "phone_rating"    "email_contact"   "email_rating"    "website_contact" "website_rating" 
#> [13] "shop_contact"    "shop_rating"
}\if{html}{\out{</div>}}

We want to extract all strings before "rating" or "contract":\if{html}{\out{<div class="r">}}\preformatted{cut_off("_contact", .vars = names(csat))
#> [1] "postal"  "phone"   "email"   "website" "shop"
}\if{html}{\out{</div>}}

We can use this to create new variables which rely on both "_contact" and
"_rating". Lets say we want to create dummy variable taking TRUE when a
customer had contact last year and gave a rating of "very satisfied" for
each of the five channels:\if{html}{\out{<div class="r">}}\preformatted{csat \%>\%
  transmute(over(cut_off("contact"),
                 ~ case_when(.("\{.x\}contact") == "within last year" &
                               .("\{.x\}rating") ==  "Very Satisfied" ~ TRUE,
                             TRUE ~ FALSE),
                 .names = "\{str\}dummy"))
#> # A tibble: 150 x 5
#>   postal_dummy phone_dummy email_dummy website_dummy shop_dummy
#>   <lgl>        <lgl>       <lgl>       <lgl>         <lgl>     
#> 1 FALSE        FALSE       FALSE       FALSE         FALSE     
#> 2 FALSE        FALSE       FALSE       FALSE         FALSE     
#> 3 FALSE        FALSE       FALSE       FALSE         FALSE     
#> 4 FALSE        TRUE        FALSE       FALSE         FALSE     
#> # ... with 146 more rows
}\if{html}{\out{</div>}}
}

