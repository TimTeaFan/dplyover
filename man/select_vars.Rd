% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/select_strings.R
\name{select_vars}
\alias{select_vars}
\alias{cut_names}
\alias{extract_names}
\title{Select string parts or patterns of column names}
\usage{
cut_names(.pattern, .remove = NULL, .vars = NULL)

extract_names(.pattern, .remove = NULL, .vars = NULL)
}
\arguments{
\item{.pattern}{Pattern to look for.}

\item{.remove}{Pattern to remove from the variable names provided in \code{.vars}.
When this argument is provided, all variables names in \code{.vars} that match
the pattern specified in \code{.remove} will be removed, before the \code{.pattern} to
look for will be applied.}

\item{.vars}{A character vector with variables names. When used inside \code{over}
all column names of the underlying data are automatically supplied to \code{.vars}.
This argument is useful when testing the functionality outside the context of
\code{over()}.}
}
\value{
A character vector.
}
\description{
These functions are \link[=selection_helpers]{selection helpers}.
They are intended to be used inside \code{over()} to extract parts or patterns of
the column names of the underlying data.
\itemize{
\item \code{\link[=cut_names]{cut_names()}} selects strings by removing (cutting off) the specified \code{.pattern}.
This functionality resembles \code{stringr::str_remove_all()}.
\item \code{\link[=extract_names]{extract_names()}} selects strings by extracting the specified \code{.pattern}.
This functionality resembles \code{stringr::str_extract()}.
}
}
\section{Examples}{


Selection helpers can be used inside \code{dplyover::over()} which in turn must be
used inside \code{dplyr::mutate} or \code{dplyr::summarise}. Let's first attach \code{dplyr}
(and \code{stringr} for comparision):\if{html}{\out{<div class="r">}}\preformatted{library(dplyr)
library(stringr)

# For better printing
iris <- as_tibble(iris)
}\if{html}{\out{</div>}}

Let's first compare \code{cut_names()} and \code{extract_names()}  to their {stringr}
equivalents \code{stringr::str_remove_all()} and \code{stringr::str_extract()}:

We can observe two main differences:

(1)  \code{cut_names()} and \code{extract_names()} only return strings where the function
was applied successfully (when characters have actually been removed or
extracted). \code{stringr::str_remove_all()} returns unmatched strings as is, while
\code{stringr::str_extract()} returns \code{NA}.\if{html}{\out{<div class="r">}}\preformatted{cut_names("Width", .vars = names(iris))
#> [1] "Sepal." "Petal."
str_remove_all(names(iris), "Width")
#> [1] "Sepal.Length" "Sepal."       "Petal.Length" "Petal."       "Species"

extract_names("Length|Width", .vars = names(iris))
#> [1] "Length" "Width"
str_extract(rep(names(iris), 2), "Length|Width")
#>  [1] "Length" "Width"  "Length" "Width"  NA       "Length" "Width"  "Length" "Width" 
#> [10] NA
}\if{html}{\out{</div>}}

(2) \code{cut_names()} and \code{extract_names()} return only unique values:\if{html}{\out{<div class="r">}}\preformatted{cut_names("Width", .vars = rep(names(iris), 2))
#> [1] "Sepal." "Petal."
str_remove_all(rep(names(iris), 2), "Width")
#>  [1] "Sepal.Length" "Sepal."       "Petal.Length" "Petal."       "Species"     
#>  [6] "Sepal.Length" "Sepal."       "Petal.Length" "Petal."       "Species"

extract_names("Length|Width", .vars = names(iris))
#> [1] "Length" "Width"
str_extract(rep(names(iris), 2), "Length|Width")
#>  [1] "Length" "Width"  "Length" "Width"  NA       "Length" "Width"  "Length" "Width" 
#> [10] NA
}\if{html}{\out{</div>}}

The examples above do not show that \code{cut_names()} removes \emph{all} strings matching
the \code{.pattern} argument, while \code{extract_names()} does only extract the \code{.pattern}
\emph{one} time:\if{html}{\out{<div class="r">}}\preformatted{cut_names("Width", .vars = "Width.Petal.Width")
#> [1] ".Petal."
str_remove_all("Width.Petal.Width", "Width")
#> [1] ".Petal."

extract_names("Width", .vars = "Width.Petal.Width")
#> [1] "Width"
str_extract("Width.Petal.Width", "Width")
#> [1] "Width"
}\if{html}{\out{</div>}}

Within \code{\link[=over]{over()}} \code{cut_names()} and \code{extract_names()} automatically use the
column names of the underlying data:\if{html}{\out{<div class="r">}}\preformatted{iris \%>\%
mutate(over(cut_names(".Width"),
            ~ .("\{.x\}.Width") * .("\{.x\}.Length"),
            .names = "Product_\{x\}"))
#> # A tibble: 150 x 7
#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species Product_Sepal
#>          <dbl>       <dbl>        <dbl>       <dbl> <fct>           <dbl>
#> 1          5.1         3.5          1.4         0.2 setosa           17.8
#> 2          4.9         3            1.4         0.2 setosa           14.7
#> 3          4.7         3.2          1.3         0.2 setosa           15.0
#> 4          4.6         3.1          1.5         0.2 setosa           14.3
#> # ... with 146 more rows, and 1 more variable: Product_Petal <dbl>

iris \%>\%
  mutate(over(extract_names("Length|Width"),
              ~.("Petal.\{.x\}") * .("Sepal.\{.x\}"),
             .names = "Product_\{x\}"))
#> # A tibble: 150 x 7
#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species Product_Length
#>          <dbl>       <dbl>        <dbl>       <dbl> <fct>            <dbl>
#> 1          5.1         3.5          1.4         0.2 setosa            7.14
#> 2          4.9         3            1.4         0.2 setosa            6.86
#> 3          4.7         3.2          1.3         0.2 setosa            6.11
#> 4          4.6         3.1          1.5         0.2 setosa            6.9 
#> # ... with 146 more rows, and 1 more variable: Product_Width <dbl>
}\if{html}{\out{</div>}}

What problem does \code{cut_names()} solve?
In the example above using \code{cut_names()} might not seem helpful, since we could easily
use \code{c("Sepal", "Petal")} instead. However, there are cases where we have
data with a lot of similar pairs of variables sharing a common prefix or
suffix. If we want to loop over them using \code{over()} then \code{cut_names()} comes
in handy.

The usage of \code{extract_names()} might be less obvious. Lets look at raw data
from a customer satifsaction survey which contains the following variables.\if{html}{\out{<div class="r">}}\preformatted{csatraw \%>\% glimpse(width = 50)
#> Rows: 150
#> Columns: 15
#> $ cust_id    <chr> "61297", "07545", "03822", "8~
#> $ type       <chr> "existing", "existing", "exis~
#> $ product    <chr> "advanced", "advanced", "prem~
#> $ item1      <dbl> 3, 2, 2, 4, 4, 3, 1, 3, 3, 2,~
#> $ item1_open <chr> "12", "22", "21, 22, 23", "12~
#> $ item2a     <dbl> 2, 2, 2, 3, 3, 0, 3, 2, 2, 0,~
#> $ item2b     <dbl> 3, 2, 5, 5, 2, NA, 3, 3, 4, N~
#> $ item3a     <dbl> 2, 3, 3, 2, 3, 2, 3, 3, 0, 1,~
#> $ item3b     <dbl> 2, 4, 5, 3, 5, 3, 4, 2, NA, 2~
#> $ item4a     <dbl> 0, 2, 0, 0, 3, 3, 3, 2, 2, 2,~
#> $ item4b     <dbl> NA, 3, NA, NA, 5, 2, 3, 5, 3,~
#> $ item5a     <dbl> 2, 3, 2, 2, 3, 1, 3, 2, 3, 1,~
#> $ item5b     <dbl> 5, 2, 3, 4, 1, 3, 3, 1, 3, 2,~
#> $ item6a     <dbl> 2, 2, 3, 1, 3, 3, 3, 2, 3, 2,~
#> $ item6b     <dbl> 3, 1, 2, 2, 5, 4, 4, 2, 2, 2,~
}\if{html}{\out{</div>}}

The survey has several 'item's consisting of two sub-questions / variables 'a'
and 'b'. Lets say we want to calculate the product of those two variables for
each item. \code{extract_names()} helps us to select all variables containing
'item' followed by a digit using the regex \code{"item\\\\d"} as \code{.pattern}.
However, there is 'item1'  and 'item1_open' which are not followed by \code{a} and
\code{b}. \code{extract_names()} lets us exclude these items by setting the \code{.remove}
argument to \verb{[^item1]}:\if{html}{\out{<div class="r">}}\preformatted{csatraw \%>\%
 transmute(over(extract_names("item\\\\d", "^item1"),
                ~ .("\{.x\}a") * .("\{.x\}b"))
 )
#> # A tibble: 150 x 5
#>   item2 item3 item4 item5 item6
#>   <dbl> <dbl> <dbl> <dbl> <dbl>
#> 1     6     4    NA    10     6
#> 2     4    12     6     6     2
#> 3    10    15    NA     6     6
#> 4    15     6    NA     8     2
#> # ... with 146 more rows
}\if{html}{\out{</div>}}
}

