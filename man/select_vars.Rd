% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/select_vars.R
\name{select_vars}
\alias{select_vars}
\alias{cut_names}
\alias{extract_names}
\title{Select string parts or patterns of column names}
\usage{
cut_names(.pattern, .select = NULL, .vars = NULL)

extract_names(.pattern, .select = NULL, .vars = NULL)
}
\arguments{
\item{.pattern}{Pattern to look for.}

\item{.select}{Pattern to further select and narrow down the variable names
provided in \code{.vars}. When this argument is provided the variables names in
\code{.vars} will be narrowed down to those who match the pattern specified in
\code{.select}.}

\item{.vars}{A character vector with variables names. When used inside \code{over}
all column names of the underlying data are automatically supplied to \code{.vars}.
This argument is useful when testing the functionality outside the context of
\code{over()}.}
}
\value{
A character vector.
}
\description{
These functions are \link[=selection_helpers]{selection helpers}. They are intended
to be used inside \code{over()} to extract parts or patterns of the column names of
the underlying data.
\itemize{
\item \code{\link[=cut_names]{cut_names()}} selects strings by removing (cutting off) the specified \code{.pattern}.
This functionality resembles \code{stringr::str_remove_all()}.
\item \code{\link[=extract_names]{extract_names()}} selects strings by extracting the specified \code{.pattern}.
This functionality resembles \code{stringr::str_extract()}.
}
}
\section{Examples}{


Selection helpers can be used inside \code{dplyover::over()} which in turn must be
used inside \code{dplyr::mutate} or \code{dplyr::summarise}. Let's first attach \code{dplyr}
(and \code{stringr} for comparision):\if{html}{\out{<div class="r">}}\preformatted{library(dplyr)
library(stringr)

# For better printing
iris <- as_tibble(iris)
}\if{html}{\out{</div>}}

Let's first compare \code{\link[=cut_names]{cut_names()}} and \code{\link[=extract_names]{extract_names()}}  to their {stringr}
equivalents \code{stringr::str_remove_all()} and \code{stringr::str_extract()}:

We can observe two main differences:

(1)  \code{\link[=cut_names]{cut_names()}} and \code{\link[=extract_names]{extract_names()}} only return strings where the function
was applied successfully (when characters have actually been removed or
extracted). \code{stringr::str_remove_all()} returns unmatched strings as is, while
\code{stringr::str_extract()} returns \code{NA}.\if{html}{\out{<div class="r">}}\preformatted{cut_names("Width", .vars = names(iris))
#> [1] "Sepal." "Petal."
str_remove_all(names(iris), "Width")
#> [1] "Sepal.Length" "Sepal."       "Petal.Length" "Petal."       "Species"

extract_names("Length|Width", .vars = names(iris))
#> [1] "Length" "Width"
str_extract(rep(names(iris), 2), "Length|Width")
#>  [1] "Length" "Width"  "Length" "Width"  NA       "Length" "Width"  "Length"
#>  [9] "Width"  NA
}\if{html}{\out{</div>}}

(2) \code{\link[=cut_names]{cut_names()}} and \code{\link[=extract_names]{extract_names()}} return only unique values:\if{html}{\out{<div class="r">}}\preformatted{cut_names("Width", .vars = rep(names(iris), 2))
#> [1] "Sepal." "Petal."
str_remove_all(rep(names(iris), 2), "Width")
#>  [1] "Sepal.Length" "Sepal."       "Petal.Length" "Petal."       "Species"     
#>  [6] "Sepal.Length" "Sepal."       "Petal.Length" "Petal."       "Species"

extract_names("Length|Width", .vars = names(iris))
#> [1] "Length" "Width"
str_extract(rep(names(iris), 2), "Length|Width")
#>  [1] "Length" "Width"  "Length" "Width"  NA       "Length" "Width"  "Length"
#>  [9] "Width"  NA
}\if{html}{\out{</div>}}

The examples above do not show that \code{\link[=cut_names]{cut_names()}} removes \emph{all} strings matching
the \code{.pattern} argument, while \code{\link[=extract_names]{extract_names()}} does only extract the \code{.pattern}
\emph{one} time:\if{html}{\out{<div class="r">}}\preformatted{cut_names("Width", .vars = "Width.Petal.Width")
#> [1] ".Petal."
str_remove_all("Width.Petal.Width", "Width")
#> [1] ".Petal."

extract_names("Width", .vars = "Width.Petal.Width")
#> [1] "Width"
str_extract("Width.Petal.Width", "Width")
#> [1] "Width"
}\if{html}{\out{</div>}}

Within \code{\link[=over]{over()}} \code{\link[=cut_names]{cut_names()}} and \code{\link[=extract_names]{extract_names()}} automatically use the
column names of the underlying data:\if{html}{\out{<div class="r">}}\preformatted{iris \%>\%
mutate(over(cut_names(".Width"),
            ~ .("\{.x\}.Width") * .("\{.x\}.Length"),
            .names = "Product_\{vec\}"))
#> # A tibble: 150 x 7
#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species Product_Sepal
#>          <dbl>       <dbl>        <dbl>       <dbl> <fct>           <dbl>
#> 1          5.1         3.5          1.4         0.2 setosa           17.8
#> 2          4.9         3            1.4         0.2 setosa           14.7
#> 3          4.7         3.2          1.3         0.2 setosa           15.0
#> 4          4.6         3.1          1.5         0.2 setosa           14.3
#> # ... with 146 more rows, and 1 more variable: Product_Petal <dbl>

iris \%>\%
  mutate(over(extract_names("Length|Width"),
              ~.("Petal.\{.x\}") * .("Sepal.\{.x\}"),
             .names = "Product_\{vec\}"))
#> # A tibble: 150 x 7
#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species Product_Length
#>          <dbl>       <dbl>        <dbl>       <dbl> <fct>            <dbl>
#> 1          5.1         3.5          1.4         0.2 setosa            7.14
#> 2          4.9         3            1.4         0.2 setosa            6.86
#> 3          4.7         3.2          1.3         0.2 setosa            6.11
#> 4          4.6         3.1          1.5         0.2 setosa            6.9 
#> # ... with 146 more rows, and 1 more variable: Product_Width <dbl>
}\if{html}{\out{</div>}}

What problem does \code{\link[=cut_names]{cut_names()}} solve?
In the example above using \code{\link[=cut_names]{cut_names()}} might not seem helpful, since we could easily
use \code{c("Sepal", "Petal")} instead. However, there are cases where we have
data with a lot of similar pairs of variables sharing a common prefix or
suffix. If we want to loop over them using \code{over()} then \code{\link[=cut_names]{cut_names()}} comes
in handy.

The usage of \code{\link[=extract_names]{extract_names()}} might be less obvious. Lets look at raw data
from a customer satifsaction survey which contains the following variables.\if{html}{\out{<div class="r">}}\preformatted{csatraw \%>\% glimpse(width = 50)
#> Rows: 150
#> Columns: 14
#> $ cust_id <chr> "61297", "07545", "03822", "8...
#> $ type    <chr> "existing", "existing", "exis...
#> $ product <chr> "advanced", "advanced", "prem...
#> $ item1   <dbl> 3, 2, 2, 4, 4, 3, 1, 3, 3, 2,...
#> $ item2a  <dbl> 1, 2, 3, 1, 1, 0, 1, 2, 0, 1,...
#> $ item2b  <dbl> 2, 3, 3, 3, 2, NA, 5, 2, NA, ...
#> $ item3a  <dbl> 2, 2, 2, 3, 3, 0, 3, 0, 0, 3,...
#> $ item3b  <dbl> 4, 4, 1, 5, 2, NA, 3, NA, NA,...
#> $ item4a  <dbl> 3, 3, 2, 3, 3, 3, 2, 3, 2, 1,...
#> $ item4b  <dbl> 1, 3, 3, 2, 3, 1, 5, 2, 4, 2,...
#> $ item5a  <dbl> 0, 2, 1, 2, 2, 3, 2, 2, 2, 1,...
#> $ item5b  <dbl> NA, 5, 3, 2, 3, 2, 4, 4, 1, 2...
#> $ item6a  <dbl> 2, 1, 0, 2, 3, 3, 3, 0, 2, 2,...
#> $ item6b  <dbl> 3, 1, NA, 4, 2, 5, 1, NA, 3, ...
}\if{html}{\out{</div>}}

The survey has several \code{item}s consisting of two sub-questions / variables \code{a}
and \code{b}. Lets say we want to calculate the product of those two variables for
each item. \code{\link[=extract_names]{extract_names()}} helps us to select all variables containing
\code{"item"} followed by a digit using as regex \code{"item\\\\d"} as \code{.pattern}.
However, there is \code{item1} which is only one variable not followed by \code{a} and
\code{b}. \code{\link[=extract_names]{extract_names()}} lets us exclude this item by setting the \code{.select}
argument to \verb{[^item1]}:\if{html}{\out{<div class="r">}}\preformatted{csatraw \%>\%
 transmute(over(extract_names("item\\\\d", "[^item1]"),
                ~ .("\{.x\}a") * .("\{.x\}b"))
 )
#> # A tibble: 150 x 5
#>   item2 item3 item4 item5 item6
#>   <dbl> <dbl> <dbl> <dbl> <dbl>
#> 1     2     8     3    NA     6
#> 2     6     8     9    10     1
#> 3     9     2     6     3    NA
#> 4     3    15     6     4     8
#> # ... with 146 more rows
}\if{html}{\out{</div>}}
}

