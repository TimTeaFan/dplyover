% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/over.R
\name{over}
\alias{over}
\title{Apply one or several functions to a character vector in 'dplyr'}
\usage{
over(.strs, .fns, ..., .names = NULL)
}
\arguments{
\item{.strs}{A character vector to apply functions to. Instead of a character
vector a <\code{\link[=string_selection_helpers]{string selection helper}}> or any other function
that evaluates to a character vector can be used. Note that \code{over()} must
only be used to create 'new' columns and will throw an error if \code{.strs}
contains existing column names. To transform existing columns use \code{\link[dplyr:across]{dplyr::across()}}.}

\item{.fns}{Functions to apply to each of the selected strings. Note that for
functions that expect variable names as input, the selected strings need to
be turned into symbols and evaluated early. <\code{\link[rlang:nse-force]{rlang's forcing operators}}>
do not work as expected in regular dplyr calls. See the examples below and the \code{vignette("over")}
for \code{over()}'s genuine forcing function \code{\link[=.]{.()}}.

Possible values are:
\itemize{
\item A function
\item A purrr-style lambda
\item A list of functions/lambdas
}

For examples see below.

Note that, unlike \code{across()}, \code{over()} does not accept \code{NULL} as a
value to `.fns``.}

\item{...}{Additional arguments for the function calls in \code{.fns}.}

\item{.names}{A glue specification that describes how to name the output
columns. This can use \code{{str}} to stand for the selected string name, and
\code{{fn}} to stand for the name of the function being applied. The default
(\code{NULL}) is equivalent to \code{"{str}"} for the single function case and
\code{"{str}_{fn}"} for the case where a list is used for \code{.fns}.}
}
\value{
A tibble with one column for each string in \code{.strs} and each function in \code{.fns}.
}
\description{
\code{over()} makes it easy to create new colums inside a \code{\link[dplyr:mutate]{dplyr::mutate()}} or
\code{\link[dplyr:summarise]{dplyr::summarise()}} call by applying a function (or a set of functions) to
a character vector using a syntax similar to \code{\link[dplyr:across]{dplyr::across()}}.
The main difference is that \code{\link[dplyr:across]{dplyr::across()}} transforms or creates new
columns based on existing ones, while \code{over()} creates new columns based on a
character vector to which it will apply one or several functions. Whereas
\code{\link[dplyr:across]{dplyr::across()}} allows \code{tidy-selection} helpers to select columns,
\code{over()} provides its own helper functions to select strings based on either
(1) column names or (2) values of specified columns. See \code{vignette("over")}
and \code{vignette("string_selection_helpers")} for more details.
}
\examples{
# over() has two main use cases:

# (1) The strings in `.strs` are used to construct column names (sharing the same stem)
# in a function call. Here it is important to, first, turn the strings into
# symbols and then to evaluate them early. Consider the following only as an
# example to understand what would be necessary to turn strings into column
# names in a call to `over()`.

iris \%>\%
  mutate(over(c("Sepal", "Petal"),
              ~ mean(eval(sym(paste0(.x,".Width"))))
              ))

# Note that rlang's forcing operator `!!` is not supported inside `over()`.
\dontrun{
  mutate(over(c("Sepal", "Petal"),
              ~ mean(!! sym(paste0(.x,".Width")))
              ))
}

# To make writing anonymous functions easier, `over()` comes with a genuine
# forcing function `.()` which supports glue syntax and takes a string as
# argument. This function is basically a wrapper around `eval_tidy(sym(glue(...)))`.
# The purrr-style formula from above with special evaluation using `.()`:
iris \%>\%
  mutate(over(c("Sepal", "Petal"),
              ~ mean(.("{.x}.Width"))
              ))

# `.()` also works with anonymous functions
iris \%>\%
  summarise(over(c("Sepal", "Petal"),
                function(x) mean(.("{x}.Width"))
                ))

# A named list of functions
iris \%>\%
  mutate(over(c("Sepal", "Petal"),
              list(product = ~ .("{.x}.Width") * .("{.x}.Length"),
                   sum = ~ .("{.x}.Width") + .("{.x}.Length")
              )))

# Use the .names argument to control the output names
iris \%>\%
  mutate(over(c("Sepal", "Petal"),
              list(product = ~ .("{.x}.Width") * .("{.x}.Length"),
                   sum = ~ .("{.x}.Width") + .("{.x}.Length")),
              .names = "{fn}_{str}"))



# (2) In the second use case the strings in `.strs` are used as values and
# mostly matched against conditions inside the functions `.fns`.

# Lets create a dummy variable for each unique value in 'Species':
iris \%>\%
  mutate(over(as.character(unique(Species)),
             ~ if_else(Species == .x, 1, 0)))

# [`get_values()`] is a wrapper around `as.character(unique(...))`:
iris_tbl \%>\%
  mutate(over(get_values(Species),
             ~ if_else(Species == .x, 1, 0)))

# Lets create several dummy variables with different thresholds
iris_tbl \%>\%
mutate(over(as.character(seq(4.5, 8, by = 0.5)),
            ~ if_else(Sepal.Length < as.numeric(.x), 1, 0),
            .names = "Sepal.Length_{str}"))

# [`chr_sq()`] and [`num()`] can shorten the above call:
iris_tbl \%>\%
mutate(over(chr_sq(4.5, 8, by = 0.5)),
            ~ if_else(Sepal.Length < num(.x), 1, 0),
            .names = "Sepal.Length_{str}"))
}
