% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/over.R
\name{over}
\alias{over}
\title{Apply one or several functions to a character vector in 'dplyr'}
\usage{
over(.strs, .fns = NULL, ..., .names = NULL)
}
\arguments{
\item{.strs}{A character vector to apply functions to. Instead of a character
vector a <\code{\link[=string_selection_helpers]{string selection helper}}> or any other function
that evaluates to a character vector can be used. Note that \code{over()} must
only be used to create 'new' columns and will throw an error if \code{.strs}
contains existing column names. To transform existing columns use \code{\link[dplyr:across]{dplyr::across()}}.}

\item{.fns}{Functions to apply to each of the selected strings. Note that for
functions that expect variable names as input, the selected strings need to
be turned into symbols and evaluated early using <\code{\link[rlang:nse-force]{rlang's forcing operators}}>.

Possible values are:
\itemize{
\item A function
\item A purrr-style lambda
\item A list of functions/lambdas
}

For examples see below.

Note that, unlike \code{across()}, \code{over()} does not accept \code{NULL} as a
value to `.fns``.}

\item{...}{Additional arguments for the function calls in \code{.fns}.}

\item{.names}{A glue specification that describes how to name the output
columns. This can use \code{{str}} to stand for the selected string name, and
\code{{fn}} to stand for the name of the function being applied. The default
(\code{NULL}) is equivalent to \code{"{str}"} for the single function case and
\code{"{str}_{fn}"} for the case where a list is used for \code{.fns}.}
}
\value{
A tibble with one column for each string in \code{.strs} and each function in \code{.fns}.
}
\description{
\code{over()} makes it easy to create new colums inside a \code{\link[dplyr:mutate]{dplyr::mutate()}} or
\code{\link[dplyr:summarise]{dplyr::summarise()}} call by applying a function (or a set of functions) to
a character vector using a syntax similar to the existing \code{\link[dplyr:across]{dplyr::across()}}.
The main difference is that \code{\link[dplyr:across]{dplyr::across()}} transforms or creates new
columns based on existing ones, while \code{over()} creates new columns based on a
character vector to which it will apply one or several functions. Whereas
\code{\link[dplyr:across]{dplyr::across()}} allows \code{tidy-selection} helpers to select columns,
\code{over()} provides its own helper functions to select strings based on either
(1) column names or (2) values of specified columns. See \code{vignette("over")}
and \code{vignette("string_selection_helpers")} for more details.
}
\examples{
# over() -----------------------------------------------------------------
# A purrr-style formula with special evaluation using `.()`
iris \%>\%
  mutate(over(c("Sepal", "Petal"),
              ~ mean(.("{.x}.Width"))))

# an anonymous function
iris \%>\%
  summarise(over(c("Sepal", "Petal"),
                function(x) mean(.("{x}.Width"))))

# A named list of functions
iris \%>\%
  mutate(over(c("Sepal", "Petal"),
              list(product = ~ .("{.x}.Width") * .("{.x}.Length"),
                   sum = ~ .("{.x}.Width") + .("{.x}.Length")
              )))

# Use the .names argument to control the output names
iris \%>\%
  mutate(over(c("Sepal", "Petal"),
              ~ .("{.x}.Width") * .("{.x}.Length"),
              .names = "Product_{str}"))

# apply a function to values of a variable
iris \%>\%
  mutate(over(as.character(unique(Species)),
             ~ if_else(Species == .x, 1, 0)))

}
