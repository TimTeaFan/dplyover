% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/select_values.R
\name{select_values}
\alias{select_values}
\alias{unique_tidy}
\alias{seq_range}
\title{Select values from variables}
\usage{
unique_tidy(
  x,
  sort = c("none", "asc", "desc"),
  sep = NULL,
  na.rm = TRUE,
  grp_data = c("warn", "ungroup", "silent")
)

seq_range(x, .by)
}
\arguments{
\item{x}{An atomic vector or list. For \code{\link[=seq_range]{seq_range()}} x must be numeric or date.}

\item{sort}{A character string indicating which sorting scheme is to be applied
to distinct values: ascending ("asc"), descending ("desc"), "none" or "levels". The
default is ascending, only if x is a factor the default is "levels".}

\item{sep}{A character vector containing regular expression(s) which are used
for splitting the values (works only if x is a character vector).}

\item{.by}{A number (or date expression) representing the increment of the sequence.}
}
\value{
\code{\link[=unique_tidy]{unique_tidy()}} returns a vector of the same type of x, with exception of
factors which are converted to type \code{"character"}.

\code{\link[=seq_range]{seq_range()}} returns an vector of type \code{"integer"} or \code{"double"}.
}
\description{
These functions are \link[=selection_helpers]{selection helpers}. They are intended
to be used inside all functions that accept a vector as argument (that is \code{over()}
and \code{crossover()} and all their variants) to extract values of a variable.
\itemize{
\item \code{\link[=unique_tidy]{unique_tidy()}} returns all distinct values (or in the case of factor variables:
levels) of a variable \code{x} which are not \code{NA}.
\item \code{\link[=seq_range]{seq_range()}} returns the sequence between the \code{range()} of a variable \code{x}.
}
}
\section{Examples}{


Selection helpers can be used inside \code{dplyover::over()} which in turn must be
used inside \code{dplyr::mutate} or \code{dplyr::summarise}. Let's first attach \code{dplyr}:\if{html}{\out{<div class="r">}}\preformatted{library(dplyr)

# For better printing
iris <- as_tibble(iris)
}\if{html}{\out{</div>}}

\code{unique_tidy()} extracts all distinct values of a column variable.
This is helpful when creating dummy variables in a loop using \code{over()}.\if{html}{\out{<div class="r">}}\preformatted{iris \%>\%
  mutate(over(unique_tidy(Species),
              ~ if_else(Species == .x, 1, 0)
              ),
         .keep = "none")
#> # A tibble: 150 x 3
#>   setosa versicolor virginica
#>    <dbl>      <dbl>     <dbl>
#> 1      1          0         0
#> 2      1          0         0
#> 3      1          0         0
#> 4      1          0         0
#> # ... with 146 more rows
}\if{html}{\out{</div>}}

\code{unique_tidy()} is just a wrapper around unique. However, it has five
differences:

(1) \code{NA} values are automatically stripped. Compare:\if{html}{\out{<div class="r">}}\preformatted{unique(c(1:3, NA))
#> [1]  1  2  3 NA
unique_tidy(c(1:3, NA))
#> [1] 1 2 3
}\if{html}{\out{</div>}}

(2) Applied on factors, \code{unique_tidy()} returns all distinct \code{levels} as
character. Compare the following:\if{html}{\out{<div class="r">}}\preformatted{fctrs <- factor(c(1:3, NA), levels = c(3:1))

fctrs \%>\% unique() \%>\% class()
#> [1] "factor"

fctrs \%>\% unique_tidy() \%>\% class()
#> [1] "character"
}\if{html}{\out{</div>}}

(3) As default, the output is sorted in ascending order for non-factors, and
is sorted as the underyling "levels" for factors. This can be controlled by
setting the \code{sort} argument. Compare:\if{html}{\out{<div class="r">}}\preformatted{# non-factors
unique(c(3,1,2))
#> [1] 3 1 2

unique_tidy(c(3,1,2))
#> [1] 3 1 2
unique_tidy(c(3,1,2), sort = "desc")
#> [1] 3 2 1
unique_tidy(c(3,1,2), sort = "none")
#> [1] 3 1 2

# factors
fctrs <- factor(c(2,1,3, NA), levels = c(3:1))

unique_tidy(fctrs)
#> [1] "3" "2" "1"
unique_tidy(fctrs, sort = "asc")
#> [1] "1" "2" "3"
unique_tidy(fctrs, sort = "desc")
#> [1] "3" "2" "1"
unique_tidy(fctrs, sort = "none")
#> [1] "3" "2" "1"
}\if{html}{\out{</div>}}

(4) When used on a character vector \code{unique_tidy} can take a separator
\code{sep} to split the elements accordingly:\if{html}{\out{<div class="r">}}\preformatted{c("1, 2, 3",
  "2, 4, 5",
  "4, 1, 7") \%>\%
  unique_tidy(., sep = ", ")
#> [1] "1" "2" "3" "4" "5" "7"
}\if{html}{\out{</div>}}

(5) When used on lists \code{unique_tidy} automatically simplifies its input
into a vector using \code{unlist}:\if{html}{\out{<div class="r">}}\preformatted{list(a = c(1:4), b = (4:6), c(5:10)) \%>\%
  unique_tidy()
#>  [1]  1  2  3  4  5  6  7  8  9 10
}\if{html}{\out{</div>}}

\code{seq_range()} generates a numeric sequence between the \code{min} and \code{max}
values of its input variable. This is helpful when creating many dummy
variables with varying thresholds.\if{html}{\out{<div class="r">}}\preformatted{iris \%>\%
  mutate(over(seq_range(Sepal.Length, 1),
              ~ if_else(Sepal.Length > .x, 1, 0),
              .names = "Sepal.Length.\{x\}"),
         .keep = "none")
#> # A tibble: 150 x 3
#>   Sepal.Length.5 Sepal.Length.6 Sepal.Length.7
#>            <dbl>          <dbl>          <dbl>
#> 1              1              0              0
#> 2              0              0              0
#> 3              0              0              0
#> 4              0              0              0
#> # ... with 146 more rows
}\if{html}{\out{</div>}}

Note that if the input variable does not have decimal places, \code{min} and \code{max} are
wrapped in \code{ceiling} and \code{floor} accordingly. This will prevent the creation of
variables that contain only \code{0} or \code{1}. Compare the output below with the
example above:\if{html}{\out{<div class="r">}}\preformatted{iris \%>\%
  mutate(over(seq(round(min(Sepal.Length), 0),
                  round(max(Sepal.Length), 0),
                  1),
              ~ if_else(Sepal.Length > .x, 1, 0),
              .names = "Sepal.Length.\{x\}"),
         .keep = "none")
#> # A tibble: 150 x 5
#>   Sepal.Length.4 Sepal.Length.5 Sepal.Length.6 Sepal.Length.7 Sepal.Length.8
#>            <dbl>          <dbl>          <dbl>          <dbl>          <dbl>
#> 1              1              1              0              0              0
#> 2              1              0              0              0              0
#> 3              1              0              0              0              0
#> 4              1              0              0              0              0
#> # ... with 146 more rows
}\if{html}{\out{</div>}}

\code{seq_range()} also works on dates:
}

