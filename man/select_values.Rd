% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/select_values.R
\name{select_values}
\alias{select_values}
\alias{dist_values}
\alias{seq_range}
\title{Select values from variables}
\usage{
dist_values(x, .sort = c("asc", "desc", "none"))

seq_range(x, .by)
}
\arguments{
\item{x}{An atomic vector. For \code{\link[=seq_range]{seq_range()}} x must be numeric or date.}

\item{.sort}{A character string indicating which sorting scheme is to be applied
to distinct values: ascending ("asc" = default), descending ("desc") or "none".}

\item{.by}{A number (or date expression) representing the increment of the sequence.}
}
\value{
\code{\link[=dist_values]{dist_values()}} returns a vector of the same type of x, with exception of
factors which are converted to type \code{"character"}.

\code{\link[=seq_range]{seq_range()}} returns an vector of type \code{"integer"} or \code{"double"}.
}
\description{
These functions are \link[=selection_helpers]{selection helpers}.
\itemize{
\item \code{\link[=dist_values]{dist_values()}} returns all distinct values (or in the case of factor variables:
levels) of a variable \code{x} which are not \code{NA}.
\item \code{\link[=seq_range]{seq_range()}} returns the sequence between the \code{range()} of a variable \code{x}.
}
}
\section{Examples}{


Selection helpers can be used inside \code{dplyover::over()} which in turn must be
used inside \code{dplyr::mutate} or \code{dplyr::summarise}. Let's first attach \code{dplyr}:\if{html}{\out{<div class="r">}}\preformatted{library(dplyr)

# For better printing
iris <- as_tibble(iris)
}\if{html}{\out{</div>}}

\code{dist_values()} extracts all distinct values of a column variable.
This is helpful when creating dummy variables in a loop using \code{over()}.\if{html}{\out{<div class="r">}}\preformatted{iris \%>\%
  mutate(over(dist_values(Species),
              ~ if_else(Species == .x, 1, 0)
              ),
         .keep = "none")
#> # A tibble: 150 x 3
#>   setosa versicolor virginica
#>    <dbl>      <dbl>     <dbl>
#> 1      1          0         0
#> 2      1          0         0
#> 3      1          0         0
#> 4      1          0         0
#> # ... with 146 more rows
}\if{html}{\out{</div>}}

While the output in the example above is identical to \code{unique()},
\code{dist_values()} has three differences:

(1) \code{NA} values are automatically stripped. Compare:\if{html}{\out{<div class="r">}}\preformatted{unique(c(1:3, NA))
#> [1]  1  2  3 NA
dist_values(c(1:3, NA))
#> [1] 1 2 3
}\if{html}{\out{</div>}}

(2) Applied on factors, \code{dist_values()} returns all distinct \code{levels} as
character. Compare:\if{html}{\out{<div class="r">}}\preformatted{factor(c(1:3, NA)) \%>\%
  as.factor() \%>\%
  unique() \%>\%
  class()
#> [1] "factor"

factor(c(1:3, NA)) \%>\%
  as.factor() \%>\%
  dist_values() \%>\%
  class()
#> [1] "character"
}\if{html}{\out{</div>}}

(3) As default, the output is sorted in ascending order. This can be
controlled by setting the \code{.sort} argument. Compare:\if{html}{\out{<div class="r">}}\preformatted{unique(c(3,1,2))
#> [1] 3 1 2

dist_values(c(3,1,2))
#> [1] 1 2 3
dist_values(c(3,1,2), .sort = "desc")
#> [1] 3 2 1
dist_values(c(3,1,2), .sort = "none")
#> [1] 3 1 2
}\if{html}{\out{</div>}}

\code{seq_range()} generates a numeric sequence between the \code{min} and \code{max}
values of its input variable. This is helpful when creating many dummy
variables with varying thresholds.\if{html}{\out{<div class="r">}}\preformatted{iris \%>\%
  mutate(over(seq_range(Sepal.Length, 1),
              ~ if_else(Sepal.Length > .x, 1, 0),
              .names = "Sepal.Length.\{x\}"),
         .keep = "none")
#> # A tibble: 150 x 3
#>   Sepal.Length.5 Sepal.Length.6 Sepal.Length.7
#>            <dbl>          <dbl>          <dbl>
#> 1              1              0              0
#> 2              0              0              0
#> 3              0              0              0
#> 4              0              0              0
#> # ... with 146 more rows
}\if{html}{\out{</div>}}

Note that if the input variable does not have decimal places, \code{min} and \code{max} are
wrapped in \code{ceiling} and \code{floor} accordingly. This will prevent the creation of
variables that contain only \code{0} or \code{1}. Compare the output below with the
example above:\if{html}{\out{<div class="r">}}\preformatted{iris \%>\%
  mutate(over(seq(round(min(Sepal.Length), 0),
                  round(max(Sepal.Length), 0),
                  1),
              ~ if_else(Sepal.Length > .x, 1, 0),
              .names = "Sepal.Length.\{x\}"),
         .keep = "none")
#> # A tibble: 150 x 5
#>   Sepal.Length.4 Sepal.Length.5 Sepal.Length.6 Sepal.Length.7 Sepal.Length.8
#>            <dbl>          <dbl>          <dbl>          <dbl>          <dbl>
#> 1              1              1              0              0              0
#> 2              1              0              0              0              0
#> 3              1              0              0              0              0
#> 4              1              0              0              0              0
#> # ... with 146 more rows
}\if{html}{\out{</div>}}

\code{seq_range()} also works on dates:\if{html}{\out{<div class="r">}}\preformatted{some_dates <- c(as.Date("2020-01-02"),
                as.Date("2020-05-02"),
                as.Date("2020-03-02"))


some_dates \%>\%
  seq_range(., "1 month")
#> [1] "2020-01-02" "2020-02-02" "2020-03-02" "2020-04-02" "2020-05-02"
}\if{html}{\out{</div>}}
}

