% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/crossover.R
\name{crossoverx}
\alias{crossoverx}
\title{Apply functions to a set of columns and a vector simultaniously in 'dplyr'}
\usage{
crossoverx(
  .xcols = dplyr::everything(),
  .y,
  .fns,
  ...,
  .names = NULL,
  .names_fn = NULL
)
}
\arguments{
\item{.xcols}{<\code{\link[=dplyr_tidy_select]{tidy-select}}> Columns to transform.
Because \code{crossoverx()} is used within functions like \code{summarise()} and
\code{mutate()}, you can't select or compute upon grouping variables.}

\item{.y}{An atomic vector or list to apply functions to.}

\item{.fns}{Functions to apply to each column in \code{.xcols} and element in \code{.y}.

Possible values are:
\itemize{
\item A function
\item A purrr-style lambda
\item A list of functions/lambdas
}

Note that \code{NULL} is not accepted as argument to \code{.fns}.}

\item{...}{Additional arguments for the function calls in \code{.fns}.}

\item{.names}{A glue specification that describes how to name the output
columns. This can use:
\itemize{
\item \code{{xcol}} to stand for the selected column name,
\item \code{{y}} to stand for the selected vector element, and
\item \code{{fn}} to stand for the name of the function being applied.
}

The default (\code{NULL}) is equivalent to \code{"{xcol}_{y}"} for the single function
case and \code{"{xcol}_{y}_{fn}"} for the case where a list is used for \code{.fns}.

Note that, depending on the nature of the underlying object in \code{.y},
specifying \code{{y}} will yield different results:
\itemize{
\item If \code{.y} is an unnamed atomic vector, \code{{y}} will represent each value.
\item If \code{.y} is a named list or atomic vector, \code{{y}} will represent each name.
\item If \code{.y} is an unnamed list, \code{{y}} will be the index number running from 1 to \code{length(y)}.
}

This standard behavior (interpretation of \code{{y}}) can be overwritten by
directly specifying:
\itemize{
\item \code{{y_val}} for \code{.y}'s values
\item \code{{y_nm}} for its names
\item \code{{y_idx}} for its index numbers
}

Alternatively, a character vector of length equal to the number of columns to
be created can be supplied to \code{.names}. Note that in this case, the glue
specification described above is not supported.}

\item{.names_fn}{Optionally, a function that is applied after the glue
specification in \code{.names} has been evaluated. This is, for example, helpful,
in case the resulting names need to be further cleaned or trimmed.}
}
\value{
\code{crossoverx()} returns a tibble with one column for each combination of
columns in \code{.xcols}, elements in \code{.y} and functions in \code{.fns}.
}
\description{
\code{crossoverx()} combines the functionality of \code{\link[dplyr:across]{dplyr::across()}} with \code{\link[=over]{over()}}
by iterating simultaneously over (i) a set of columns (\code{.xcols}) and (ii)
a vector or list (\code{.y}). \code{crossoverx()} \emph{always} applies the functions in
\code{.fns} in a \emph{nested} way to a combination of both inputs. There are, however,
two different ways in which the functions in \code{.fns} are applied.

When \code{.y} is a vector or list, each function in \code{.fns} is applied to
\emph{all pairwise combinations} between columns in \code{.xcols} and elements in
\code{.y} (this resembles the behavior of \code{over2x()} and \code{across2x()}).
}
\section{Examples}{


For the basic functionality please refer to the examples in \code{\link[=over]{over()}} and
\code{\link[dplyr:across]{dplyr::across()}}.\if{html}{\out{<div class="r">}}\preformatted{library(dplyr)

# For better printing
iris <- as_tibble(iris)
}\if{html}{\out{</div>}}
\subsection{Creating many similar variables for mulitple columns}{

If \code{.y} is a vector or list, \code{crossoverx()} loops every combination between
columns in \code{.xcols} and elements in \code{.y} over the functions in \code{.fns}. This
is helpful in cases where we want to create a batch of similar variables with
only slightly changes in the arguments of the calling function. A good example
are lagged variables. Below we create five lagged variables for each
'Sepal.Length' and  'Sepal.Width'. To create nice names we use a named list
as argument in \code{.fns} and specify the glue syntax in \code{.names}.\if{html}{\out{<div class="r">}}\preformatted{ iris \%>\%
   transmute(
     crossoverx(starts_with("sepal"),
               1:5,
               list(lag = ~ lag(.x, .y)),
               .names = "\{xcol\}_\{fn\}\{y\}")) \%>\%
   glimpse
#> Rows: 150
#> Columns: 10
#> $ Sepal.Length_lag1 <dbl> NA, 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4~
#> $ Sepal.Length_lag2 <dbl> NA, NA, 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9,~
#> $ Sepal.Length_lag3 <dbl> NA, NA, NA, 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, ~
#> $ Sepal.Length_lag4 <dbl> NA, NA, NA, NA, 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4~
#> $ Sepal.Length_lag5 <dbl> NA, NA, NA, NA, NA, 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.~
#> $ Sepal.Width_lag1  <dbl> NA, 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7~
#> $ Sepal.Width_lag2  <dbl> NA, NA, 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1,~
#> $ Sepal.Width_lag3  <dbl> NA, NA, NA, 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, ~
#> $ Sepal.Width_lag4  <dbl> NA, NA, NA, NA, 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2~
#> $ Sepal.Width_lag5  <dbl> NA, NA, NA, NA, NA, 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.~
}\if{html}{\out{</div>}}
}
}

\seealso{
Other members of the <\code{\link[=over_across_family]{over-across function family}}>.
}
